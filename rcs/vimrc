"
" .vimrc (shaw@vranix.com)
"
set nocompatible
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

Plugin 'gmodarelli/solarize'
Plugin 'altercation/vim-colors-solarized'
Plugin 'jelera/vim-javascript-syntax'
Plugin 'pangloss/vim-javascript'
Plugin 'tpope/vim-fugitive'
Plugin 'vim-scripts/DeleteTrailingWhitespace'
Plugin 'vim-scripts/matchit.zip'
Plugin 'ervandew/supertab'
Plugin 'fatih/vim-go'
Plugin 'othree/html5.vim'
Plugin 'mitechie/pyflakes-pathogen'
Plugin 'fs111/pydoc.vim'
Plugin 'hynek/vim-python-pep8-indent'
Plugin 'ingydotnet/yaml-vim'
Plugin 'tmux-plugins/tpm'
Plugin 'tpope/vim-fireplace'
Plugin 'tpope/vim-classpath'
Plugin 'vim-airline/vim-airline'
Plugin 'vim-airline/vim-airline-themes'
Plugin 'neomake/neomake'
Plugin 'Shougo/deoplete.nvim'
Plugin 'zchee/deoplete-go'
Plugin 'ternjs/tern_for_vim'


" All of your Plugins must be added before the following line
call vundle#end()
syntax on
"filetype on
filetype plugin indent on

set mouse=a

set rtp+=~/repos/fzf

let g:edit_modes = [ "code", "email" ]
let g:edit_mode = 0
let g:code_modes = [ "rbt", "kernel" ]
let g:code_mode = 0

let mapleader = ","
let maplocalleader = ","

let g:airline_powerline_fonts = 1
let g:airline_section_b='' " Disable showing branch cause it crowds the filename
let g:airline_section_y='' " Disable filetype cause it's mostly useless

" virtualenv for neovim, has neovim python package installed
let g:python3_host_prog = '/home/shaw/.virtualenvs/neovim/bin/python'

let g:neomake_javascript_enabled_makers = ['eslint']
let g:neomake_verbose = 0

if $GRUF_PROJECT =~ 'monorepo'
    let g:neomake_python_pylint_maker = {
        \ 'args': [
            \ '--rcfile=' . $MONOREPO . '/.pylintrc',
            \ '--output-format=text',
            \ '--msg-template="{path}:{line}:{column}:{C}: [{symbol}] {msg}"',
            \ '--reports=no'
        \ ]
    \ }
endif

" Whitespace related
"
" To disable showing trailing whitespace:
" let g:ShowTrailingWhitespace = 0
" Auto-delete whitespace automatically, no ask
let g:DeleteTrailingWhitespace = 1
let g:DeleteTrailingWhitespace_Action = 'delete'

let g:deoplete#enable_at_startup = 1
" let g:deoplete#disable_auto_complete = 1
" autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif

"set fileformat=unix
set completeopt+=menu
set notimeout
set ttimeout
set ttimeoutlen=100
set backspace=indent,eol,start
set directory=.
set nowrap
set nosol
" show filename in X window frame
"set title
" show nothing in window frame on exit
set titleold=
set scrollopt=ver
set ic
set smartcase
set incsearch
set nohlsearch
set inccommand=split
" placed here for webpack hmr
set backupcopy=yes

" make asterick search work in visual mode
vmap * "yy:let @/='\(' . @y . '\'<cr>n

source ${GRUF_CONFIG}/gruf.vimrc

set tags=tags,${GRUF_PROJECT}/tags

"
" :cs help
"
"   's'	  symbol: find all references to the token under cursor
"   'g'   global: find global definition(s) of the token under cursor
"   'c'   calls:  find all calls to the function name under cursor
"   't'   text:   find all instances of the text under cursor
"   'e'   egrep:  egrep search for the word under cursor
"   'f'   file:   open the filename under cursor
"   'i'   includes: find files that include the filename under cursor
"   'd'   called: find functions that function under cursor calls
"
"   <c-\>  same window
"   <c-spacebar> horiz split
"   <c-spacebar> <c-spacebar> vert split
"

if has("cscope")
    set nocscopetag
    set nocsverb

    if filereadable("cscope.out")
        cs add cscope.out
    elseif filereadable("ncscope.out")
        cs add ncscope.out
    endif

    if filereadable(expand("$KERN/cscope.out"))
        cs add $KERN/cscope.out
    elseif filereadable("$KERN/ncscope.out")
        cs add $KERN/ncscope.out
    endif

    "
    " The following maps all invoke one of the following cscope search types:
    "
    "   's'   symbol: find all references to the token under cursor
    "   'g'   global: find global definition(s) of the token under cursor
    "   'c'   calls:  find all calls to the function name under cursor
    "   't'   text:   find all instances of the text under cursor
    "   'e'   egrep:  egrep search for the word under cursor
    "   'f'   file:   open the filename under cursor
    "   'i'   includes: find files that include the filename under cursor
    "   'd'   called: find functions that function under cursor calls
    "
    " Below are three sets of the maps: one set that just jumps to your
    " search result, one that splits the existing vim window horizontally and
    " diplays your search result in the new window, and one that does the same
    " thing, but does a vertical split instead (vim 6 only).
    "
    " I've used CTRL-\ and CTRL-@ as the starting keys for these maps, as it's
    " unlikely that you need their default mappings (CTRL-\'s default use is
    " as part of CTRL-\ CTRL-N typemap, which basically just does the same
    " thing as hitting 'escape': CTRL-@ doesn't seem to have any default use).
    " If you don't like using 'CTRL-@' or CTRL-\, , you can change some or all
    " of these maps to use other keys.  One likely candidate is 'CTRL-_'
    " (which also maps to CTRL-/, which is easier to type).  By default it is
    " used to switch between Hebrew and English keyboard mode.
    "
    " All of the maps involving the <cfile> macro use '^<cfile>$': this is so
    " that searches over '#include <time.h>" return only references to
    " 'time.h', and not 'sys/time.h', etc. (by default cscope will return all
    " files that contain 'time.h' as part of their name).
    "
    " To do the first type of search, hit 'CTRL-\', followed by one of the
    " cscope search types above (s,g,c,t,e,f,i,d).  The result of your cscope
    " search will be displayed in the current window.  You can use CTRL-T to
    " go back to where you were before the search.
    "
    nmap <C-\>s :cs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>g :cs find g <C-R>=expand("<cword>")<CR><CR>

    nmap <C-\>c :cs find c <C-R>=expand("<cword>")<CR><CR>

    nmap <C-\>t :cs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>e :cs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-\>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-\>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-\>d :cs find d <C-R>=expand("<cword>")<CR><CR>

    " Using 'CTRL-spacebar' (intepreted as CTRL-@ by vim) then a search type
    " makes the vim window split horizontally, with search result displayed in
    " the new window.
    "
    " (Note: earlier versions of vim may not have the :scs command, but it
    " can be simulated roughly via:
    "    nmap <C-@>s <C-W><C-S> :cs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>s :scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>g :scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>c :scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>t :scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>e :scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@>f :scs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-@>i :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@>d :scs find d <C-R>=expand("<cword>")<CR><CR>

    " Hitting CTRL-space *twice* before the search type does a vertical
    " split instead of a horizontal one (vim 6 and up only)
    "
    " (Note: you may wish to put a 'set splitright' in your .vimrc
    " if you prefer the new window on the right instead of the left
    nmap <C-@><C-@>s :vert scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>g :vert scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>c :vert scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>t :vert scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>e :vert scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-@><C-@>f :vert scs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-@><C-@>i :vert scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-@><C-@>d :vert scs find d <C-R>=expand("<cword>")<CR><CR>

endif

set comments=sr:/*,mb:*,exl:*/,://,b:#,:%:XCOMM,n:>,fb:-
set comments+=b:\"

" Turn on continuation of comment characters for all file types
"autocmd FileType * setlocal formatoptions+=caroq

autocmd FileType * setlocal formatoptions+=croq

autocmd BufRead gitcommit setlocal spell spelllang=en_US textwidth=72
autocmd BufRead gitcommit setlocal fo+=t

autocmd BufEnter svn-commit.* :set textwidth=60
autocmd BufEnter svn-commit.* :set spell
autocmd BufEnter svn-commit.* :set noexpandtab
autocmd BufEnter svn-commit.* call EmailEditMode()

autocmd BufNewFile,BufRead,BufEnter *.erb setf ruby
autocmd BufNewFile,BufRead,BufEnter *.feature setf ruby
autocmd BufNewFile,BufRead,BufEnter *.gradle setf groovy
autocmd BufNewFile,BufRead,BufEnter *.json setf json

autocmd BufWritePost,BufEnter * Neomake

" When editing a file that requires root, try to save using sudo
cmap w!! %!sudo tee > /dev/null %

" ignore .pyc, .o, and .git in command-t and :e
set wildignore+=*.pyc,*.o,.git
set showmatch
set backupext=.bak
set backupdir=~/.bak
set sessionoptions=buffers,options,winpos,winsize,help,blank,globals,resize
set noerrorbells
set noshowmode "airline/powerline shows mode, so no need to show it
set showcmd
set helpheight=0
set visualbell
set t_vb=
set ruler
set laststatus=2
set go=ia
set noequalalways
set mousehide
set mousefocus
set mousemodel=extend

" vim -b: edit binary using xxd-format
augroup Binary
    au!
    au BufReadPre  *.bin let &bin=1
    au BufReadPost *.bin if &bin | %!xxd
    au BufReadPost *.bin set ft=xxd | endif
    au BufWritePre *.bin if &bin | %!xxd -r
    au BufWritePre *.bin endif
    au BufWritePost *.bin if &bin | %!xxd
    au BufWritePost *.bin set nomod | endif
augroup END

function! GotoConfig()
    cd $CONFIG_DIR
endfun

"
" Toggle fold state between closed and opened
" with the space bar. If there is no fold at
" current line, just moves forward.  If it is present,
" reverse its state. Use zf<move action> to create fold.
" zf% to create fold on function, for example.
"
function! ToggleFold()
    if foldlevel('.') == 0
        normal! l
    else
        if foldclosed('.') < 0
            . foldclose
        else
            . foldopen
        endif
    endif
    " Clear status line
    echo
endfunction
noremap <buffer> <space> :call ToggleFold()<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" abbreviations
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

ab lvb """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""<ESC>
ab #d #define
ab #i #include

map     \cf :call GetFile(expand("$CONFIG_DIR"))<CR>
map!    \cf <ESC>:call GetFile(expand("$CONFIG_DIR"))<CR>

map     \gc :call GotoConfig()<CR>
map!    \gc <ESC>:call GotoConfig()<CR>

map 	\sp :split<CR>
map!	\sp <ESC>:split<CR>
map     \yrs :YRShow<CR>
map! 	\yrs <ESC>:YRShow<CR>
nmap <silent> \ts :ts<CR>

" Launch Eclair (2.1) emulator
map 	\ee :!eclair.sh<CR><CR>
map! 	\ee <ESC>:!eclair.sh<CR><CR>

" Launch Froyo (2.2) emulator
map 	\ef :!froyo.sh<CR><CR>
map! 	\ef <ESC>:!froyo.sh<CR><CR>

" Launch Gingerbread (2.3) emulator
map 	\eg :!gingerbread.sh<CR><CR>
map! 	\eg <ESC>:!gingerbread.sh<CR><CR>

" Launch Jellybean (4.1) emulator
map 	\ej :!jellybean.sh<CR><CR>
map! 	\ej <ESC>:!jellybean.sh<CR><CR>

map 	\iv :!install-viz.sh<CR><CR>
map! 	\iv <ESC>:!install-viz.sh<CR><CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"  Function key mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map 	<F1> :w<CR>
map!  	<F1> <ESC>:w<CR>
map 	<F2> :registers<CR>
map! 	<F2> <ESC>:registers<CR>
map     <F3> :Explore<CR>
map!    <F3> <ESC>:Explore<CR>
"       <F4> is marked for toggling paste below
"map 	<F6> taken
"map! 	<F6> taken
"map 	<F7> :!ctags -R<CR><CR>
"map! 	<F7> <ESC>:!ctags -R<CR><CR>
map 	<F7> :!tlc<CR><CR>
map! 	<F7> <ESC>:!tlc<CR><CR>
" Spellcheck with F8 if editing mail using `aspell'
"autocmd FileType mail :nmap <F8> :w<CR>:!aspell -e -c %<CR>:e<CR>
"map 	<F9> :Tlist<CR>
"map! 	<F9> <ESC>:Tlist<CR>

map 	<F9> :'a,'bs/^/\/\//<CR>
map! 	<F9> <ESC>:a,'bs/^/\/\//<CR>
"map 	<F9> :execute " grep -srnw binary-files=without-match --exclude-dir=.git,Android/App/bin,Android/App/gen,Android/App/tests/ --exclude-from=/home/shaw/config/rcs/lookout.exclude.list.txt . -e " . expand("<cword>") . " " <bar> cwindow<CR>
"map! 	<F9> :execute " grep -srnw binary-files=without-match --exclude-dir=.git,Android/App/bin,Android/App/gen,Android/App/tests/ --exclude-from=/home/shaw/config/rcs/lookout.exclude.list.txt . -e " . expand("<cword>") . " " <bar> cwindow<CR>
"map 	<F11> :CommandTFlush<CR>
"map! 	<F11> <ESC>:CommandTFlush<CR>
map 	<F12> :q<CR>
map! 	<F12> <ESC>:q<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nmap n nmzz.`z
nmap N Nmzz.`z
nmap * *mzz.`z
nmap # #mzz.`z
nmap g* g*mzz.`z
nmap g# g#mzz.`z
"nmap gn :set invnu<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" alt mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map 	<m-n> :cn<CR>
map! 	<m-n> <ESC>:cn<CR>
map 	<m-p> :cp<CR>
map! 	<m-p> <ESC>:cp<CR>
map 	<m-f> :cfirst<CR>
map! 	<m-f> <ESC>:cfirst<CR>
map 	<m-l> :clist<CR>
map! 	<m-l> <ESC>:clist<CR>
map 	<m-o> :copen<CR>
map! 	<m-o> <ESC>:copen<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ctrl mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" buffers
map 	<c-p> :bp<CR>
map! 	<c-p> <esc>:bp<CR>
map 	<c-n> :bn<CR>
map! 	<c-n> <esc>:bn<CR>
map 	<c-j> :buffers<CR>
map! 	<c-j> <esc>:buffers<CR>
map 	<c-x> :bdelete<CR>
map! 	<c-x> <esc>:bdelete<CR>
map 	<c-/> :bdelete<CR>
map! 	<c-/> <esc>:bdelete<CR>

" tabs
map 	<c-s> :tabp<CR>
map! 	<c-s> <ESC>tabp<CR>
map     <c-h> :tabn<CR>
map!  	<c-h> <ESC>tabn<CR>
nnoremap \tt :tabnew<CR>
nnoremap \nt :tabnew<CR>

" comment current line
"map 	<c-k> mzI/* <ESC>A */ <ESC>`z
"map! 	<c-k> <ESC>mzI/* <ESC>A */ <ESC>`z
" uncomment current line
"map 	<c-l> :silent! s/\(.*\)\(\/\* \)\(.*\)\(\*\/\)/\1\3/<CR>
"map! 	<c-l> <ESC>:silent! s/\(.*\)\(\/\* \)\(.*\)\(\*\/\)/\1\3/<CR>
map 	<c-c> :make<CR>
" 5 ctrl-h jumps to buffer 5
"map 	<c-h> <C-^>
map 	- <C-W>-
map 	+ <C-W>+


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" ctrl tag-related mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" goto next tag in taglist
map 	<c-=> :tnext<CR>
map! 	<c-=> <ESC>:tnext<CR>
" mapping something to <c-[> breaks function key mappings
"map 	<c-[> :pop<CR>
"map! 	<c-[> <ESC>:pop<CR>

" map pageup to something reasonable
map 	<c-d> <c-b>
map 	<c-r> :'a,'bs/^/#/<CR>
nnoremap \sv :source ~/.vimrc<CR>

" toggle highlighting when searching
nnoremap \th :set invhls hls?<CR>
" toggle paste mapping to avoid things like autoindent causing 'stepped' text
nnoremap \tp :set invpaste paste?<CR>
" remove comment block
nnoremap \rcb :'a,'bs/^#//<CR>
"set pastetoggle=<F4>

"
" JAVAC/ANT INTEGRATION (he quickfix)
" ':' command  what it does
" cn go to the next error
" cp go to the previous error
" cfirst go to the first error
" clast go to the last error
" clist list all of the errors
" copen open split window of errors
"
set shell=/bin/bash
set shellpipe=2>&1\|tee
set makeef=$TMP/vim.##
set makeprg=ant\ debug
"set makeprg=make\ -f\ Makefile
autocmd BufRead *.java set efm=%A\ %#[javac]\ %f:%l:\ %m,%-Z\ %#[javac]\ %p^,%-C%.%#

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Colorschemes
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('gui_running')
    set background=light
else
    set background=dark
endif

colorscheme solarized

map <M-Esc>[62~ <MouseDown>
map! <M-Esc>[62~ <MouseDown>
map <M-Esc>[63~ <MouseUp>
map! <M-Esc>[63~ <MouseUp>
map <M-Esc>[64~ <S-MouseDown>
map! <M-Esc>[64~ <S-MouseDown>
map <M-Esc>[65~ <S-MouseUp>
map! <M-Esc>[65~ <S-MouseUp>

nnoremap <silent> <LocalLeader>t :FZF<cr>

nmap \t :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
nmap \T :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>
nmap \M :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>
nmap \m :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>

"set colorcolumn=80
" Make the 81st column standout, like setting colorcolumn
"highlight ColorColumn ctermbg=magenta
call matchadd('ColorColumn', '\%81v', 100)

"====[ Highlight matches when jumping to next ]====
" OR ELSE just highlight the match in red... (Damian Conway)
nnoremap <silent> n     n:call HLNext(0.4)<cr>
nnoremap <silent> N     N:call HLNext(0.4)<cr>
highlight WhiteOnRed ctermfg=white ctermbg=red
function! HLNext (blinktime)
    let [bufnum, lnum, col, off] = getpos('.')
    let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
    let target_pat = '\c\%#'.@/
    let ring = matchadd('WhiteOnRed', target_pat, 101)
    redraw
    exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
    call matchdelete(ring)
    redraw
endfunction

" Don't use vim's keyword completion on <tab>
"let g:SuperTabDefaultCompletionType = 'context'
" Not sure why I need this, but it prevents an extra <cr> after selecting a
" completion option
let g:SuperTabCrMapping = 0
let g:SuperTabDefaultCompletionType = '<c-n>'
let g:SuperTabClosePreviewOnPopupClose = 1

" run :GoBuild or :GoTestCompile based on the go file
function! s:build_go_files()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#cmd#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction

autocmd FileType go nmap <leader>b :<C-u>call <SID>build_go_files()<CR>
let g:go_fmt_command = "goimports"
let g:go_metalinter_autosave_enabled = ['vet', 'golint']
let g:go_auto_type_info = 1
let g:go_fmt_autosave = 1
