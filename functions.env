#!/bin/bash
#
# Collection of functions and aliases
#

# Safer way to list the contents of a directory as it doesn't have the 'empty
# dir bug'.
#
# char *dolisting(param)
#
#    print a list of the directory contents
#
#    NOTE: quote the params if they contain globs.
#          also, error checking is not that extensive ...
#
dolisting() {
    local x=
    local y=
    local tmpstr=
    local mylist=
    local mypath="$*"

    if [[ ${mypath%/\*} != "${mypath}" ]] ; then
        mypath=${mypath%/\*}
    fi

    for x in ${mypath} ; do
        [[ ! -e ${x} ]] && continue

        if [[ ! -d ${x} ]] && [[ -L ${x} || -f ${x} ]] ; then
            mylist="${mylist} $(ls "${x}" 2> /dev/null)"
        else
            [[ ${x%/} != "${x}" ]] && x=${x%/}

            cd "${x}"; tmpstr=$(ls)

            for y in ${tmpstr} ; do
                mylist="${mylist} ${x}/${y}"
            done
        fi
    done

    echo "${mylist}"
}

# void ebox(void)
# 	indicates a failure in a "box"
function ebox() {
    if [ "${RC_QUIET_STDOUT}" != "yes" ]
    then
        echo -e "${ENDCOL}  ${BRACKET}[ ${BAD}!!${BRACKET} ]${NORMAL}"
    fi
}

# void sbox(void)
# 	indicates a success in a "box"
function sbox() {
    if [ "${RC_QUIET_STDOUT}" != "yes" ]
    then
        echo -e "${ENDCOL}  ${BRACKET}[ ${GOOD}ok${BRACKET} ]${NORMAL}"
    fi
}

function egood() {
    echo $*
    sbox
}

function ebad() {
    echo $*
    ebox
}

function estatus() {
    if [ $? -eq 0 ]; then
        egood $*
    else
        ebad $*
    fi
}

# xtitle(char *title)
# 	Changes title of Xwindow.
function xtitle() {
    case "$TERM" in
        *term | rxvt)
            echo -n -e "\033]0;$*\007" ;;
        *)
            ;;
    esac
}

# pse(char *name) --> linux
# pse(int pid) --> other
# 	List the full environment of the specified process.
function pse() {
    case $OS in
        linux ) ps eww -C $1 | tr " " "\012" | sort -u
            ;;
        unix ) /usr/ucb/ps ewwwp $1 | tr " " "\012" | sort -u
            ;;
    esac
}

# Reset text attributes w/o clearing the screen.
function Reset() {
    tput sgr0
}

# prompts for a y/n from user, returning 1 or 0 respectively
function ask() {
    echo -n "$@" '[y/n] ' ; read ans

    case "$ans" in
        y*|Y*)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# ff dogbutt
# 	Find a file with case insensitive pattern in name, removing fluff.
function ff() {
    find . -type f -iname '*'$*'*' -printf "%P\n" 2>/dev/null
}

# ff dogbutt rm
# 	Find a file with case insensitive pattern $1 in name and execute $2 on it.
function fe() {
    find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;
}

# ff client
# 	Find any type of file, removing fluff.
function fa() {
    find . -iname '*'$1'*' -printf "%P\n" 2>/dev/null
}

function set_prompt_home() {
    if [ "${RC_NOCOLOR}" = "no" ]; then
        if [[ ${EUID} == 0 ]] ; then
            PS1='\[\033[00;32m\]\h\[\033[01;34m\] \W \$\[\033[00m\] '
        else
            PS1="[\u@\[\e[00;36m\]\h\[\e[37;0m\] \W \!]% "
        fi
    else
        if [[ ${EUID} == 0 ]] ; then
            # show root@ when we don't have colors
            PS1='\u@\h \W \$ '
        else
            PS1='\u@\h \w \$ '
        fi
    fi
}

function set_prompt_other() {
    if [ "${RC_NOCOLOR}" = "no" ]; then
        if [[ ${EUID} == 0 ]] ; then
            PS1='\[\033[01;31m\]\h\[\033[01;34m\] \W \$\[\033[00m\] '
        else
            PS1="[\u@\[\e[00;35m\]\h\[\e[37;0m\] \W \!]% "
        fi
    else
        if [[ ${EUID} == 0 ]] ; then
            # show root@ when we don't have colors
            PS1='\u@\h \W \$ '
        else
            PS1='\u@\h \w \$ '
        fi
    fi
}

function set_prompt_two() {
    PS2="-> "
}

#
# Living without this is just silly.
#
function is() {
    if [ -z "$1" ]; then
        return
    fi

    ps -eopid,tt,ppid,user,pcpu,time,pri,wchan,comm | head -n1 ; \
        ps -eopid,tt,ppid,user,pcpu,time,pri,wchan,comm  | grep "$@" | \
            grep -v "grep"
}

# void pid(char *progname)
#
# Return the pid of the programe specified by $1.
function pid() {
    # using grep instead of ps -C so you don't have to be too specific about
    # the command name; this might be a bad thing.  Using sed to remove the
    # whitespace that may occur if the pid was padded during format by ps.
    # Finally, grab just the pid with cut.
    #ps -eo pid,cmd | grep "$@" | grep -v "grep $@" | sed -e 's/\s*\(\w\)/\1/' | \
    ps -eopid,user,comm | grep "$@" | sed -e 's/\s*\(\w\)/\1/' | cut -d" " -f1
}

alias runtests="rake spec"

# ls
alias ls="ls $LS_DFLT_ARGS"

#
# ls long listing
#
alias ll='ls -al'

#
# ls directories
#
alias lsd='\ls -d */'

#
# ls directories long mode
#
alias lsdl='ll -d */'

#
# ls block devices
#
alias lsb='ll | grep '^b''

#
# ls hidden
#
function lsh() {
    ll | awk '{print $9}' | grep '^\.'
}

#
# ls long links
#
alias lsll='ll | grep '^l''

#
#  ls long directories (including hidden ones)
#
alias lshd='ll | grep ^d'''

#
# ls links (short listing)
#
function lsl() {
    lsll | gawk '{print $9}'
}

#
# Directory tree (like tree)
#
alias lr='ls -R | grep ":$" | sed -e '\''s/:$//'\'' -e '\''s/[^-][^\/]*\//--/g'\'' -e '\''s/^/   /'\'' -e '\''s/-/|/'\'''

alias p='pushd'
alias P='popd'

# Add newlines to path for readability
alias path='echo -e ${PATH//:/\\n}'
alias classpath='echo -e ${CLASSPATH//:/\\n}'

#
# Create a random password
#
# @param length  default 12
#
function rpass()
{
    cat /dev/urandom | tr -cd '[:graph:]' | head -c ${1:-12} && echo
}

# find
alias drmo='find . -name "*.o" -delete'

# cd
alias cdc='cd $CONFIG_DIR'
alias cd..='cd ..'
alias ..='cd ..'
alias ..='cd ..'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'

alias kvswap='find . -iregex ^.*.swp -delete'
alias svi='sudo vi'
alias svivlm='svi /var/log/messages'
alias rvi='vi -R'

alias bzip='bzip2'
alias bunzip='bunzip2'
alias diff='diff -u'
alias telnet='telnet -E'
alias ftp='ftp -i'

alias smount='sudo mount'
alias sumount='sudo umount'

### Log viewing ###
alias vvls='sudo vi /var/log/syslog'
alias tvls='sudo tail /var/log/syslog'
alias vvlm='vi /var/log/messages'
alias tvlm='tail /var/log/messages'
alias vvlk='vi /var/log/kern.log'
alias tvlk='tail /var/log/kern.log'
alias stail='sudo tail'
alias stailf='stail -f'
alias stailfm='stail -f /var/log/syslog'
alias stvlm='sudo tail /var/log/messages'

alias ack='ack-grep'

### ruby ###
alias brake='bundle exec rake'
alias bexec='bundle exec'

### tmux ###
alias tma='tmux attach -d -t'

# create named tmux session, i.e., tmux new -s dev
function tmn {
    if [ -z "$1" ]; then
        tmux
    else
        tmux new-session -s $1
    fi
}

### ssh ###
alias rmkey='ssh-keygen -f "~/.ssh/known_hosts" -R'

alias upgrade='sudo apt-get update && sudo apt-get upgrade && sudo apt-get clean'

function md() {
    mkdir "$1"
    cd "$1"
}

function cores() {
    echo $(grep -c ^processor /proc/cpuinfo)
}

alias perlinc='perl -le "print for @INC"'

function colors() {
    for i in {0..255} ; do
        printf "\x1b[38;5;${i}mcolor${i}\n"
    done
}

s() {
    if [[ $# == 0 ]]; then
        sudo $(history -p '!!')
    else
        sudo "$@"
    fi
}

extract() {
    if [ -f $1 ] ; then
      case $1 in
        *.tar.bz2)   tar xjf $1     ;;
        *.tar.gz)    tar xzf $1     ;;
        *.bz2)       bunzip2 $1     ;;
        *.rar)       unrar e $1     ;;
        *.gz)        gunzip $1      ;;
        *.tar)       tar xf $1      ;;
        *.tbz2)      tar xjf $1     ;;
        *.tgz)       tar xzf $1     ;;
        *.zip)       unzip $1       ;;
        *.Z)         uncompress $1  ;;
        *.7z)        7z x $1        ;;
        *)     echo "'$1' cannot be extracted via extract()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}


alias gco='git checkout'

install_apk() {
    if [ -z $1 ]; then
        echo "Requires filename"
        return 1
    fi

    APK_FILENAME=$1

    id=$(adb devices | grep device$ | awk -F '\\t' '{ print $1}')
    echo "Installing $APK_FILENAME to device $id"
    adb install -r $APK_FILENAME
}

# Remove all invalid directories from PATH
#
# @return String PATH
cleaned_path() {
    ruby -e "puts ENV['PATH'].split(':') \
                             .inject([]) { |r,k| r << k if File.exist?(k) ; r } \
                             .join(':')"
}
